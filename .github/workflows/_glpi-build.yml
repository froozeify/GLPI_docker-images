name: "GLPI Docker Image Build (Template)"

# This is a reusable workflow template - never run directly
# Called by: glpi.yml, glpi-nightly.yml

env:
  DOCKERHUB_IMAGE: benoitvignal/glpi_docker-images
  GHCR_IMAGE: ghcr.io/froozeify/glpi_docker-images

on:
  workflow_call:
    inputs:
      push:
        description: "Whether to push images to registries"
        required: false
        type: boolean
        default: false
      patch-url:
        description: "URL to a .diff/.patch file to apply after source download, multiple patches can be separated by space"
        required: false
        type: string
        default: ""
      php-version:
        required: false
        type: string
        default: "8.5"
      glpi-version:
        description: "GLPI version or branch to build"
        required: true
        type: string
      image-tag:
        description: "Override image tag. If not set, computed from version."
        required: false
        type: string
        default: ""
      image-suffix:
        description: "Suffix to add to computed tag (ignored if image-tag is set)"
        required: false
        type: string
        default: ""
    secrets:
      DOCKER_HUB_USERNAME:
        required: true
      DOCKER_HUB_TOKEN:
        required: true
      GHCR_USERNAME:
        required: true
      GHCR_ACCESS_TOKEN:
        required: true

jobs:
  prepare:
    name: "Prepare"
    runs-on: "ubuntu-latest"
    outputs:
      marketplace-dir: ${{ steps.set-vars.outputs.marketplace_dir }}
      artifact-prefix: ${{ steps.set-vars.outputs.artifact_prefix }}
      is-latest: ${{ steps.set-vars.outputs.is_latest }}
      is-prerelease: ${{ steps.set-vars.outputs.is_prerelease }}
      image-version: ${{ steps.set-vars.outputs.image_version }}
    steps:
      - name: "Set variables"
        id: "set-vars"
        run: |
          # Compute marketplace dir
          IMAGE_VERSION_MAJOR=$(echo "${{ inputs.glpi-version }}" | cut -d. -f1)
          MARKETPLACE_DIR="/var/glpi/marketplace"
          if [[ "$IMAGE_VERSION_MAJOR" = "10" ]]; then
            MARKETPLACE_DIR="/var/www/glpi/marketplace"
          fi
          echo "marketplace_dir=$MARKETPLACE_DIR" >> $GITHUB_OUTPUT

          # Compute artifact prefix (unique per workflow call)
          if [[ "${{ inputs.image-tag }}" != '' ]]; then
            ARTIFACT_PREFIX="${{ inputs.image-tag }}"
          else
            ARTIFACT_PREFIX="$(echo '${{ inputs.glpi-version }}' | sed -E 's|/|-|g')"
          fi
          echo "artifact_prefix=$ARTIFACT_PREFIX" >> $GITHUB_OUTPUT

          # Compute image version for metadata-action
          IMAGE_VERSION="$(echo '${{ inputs.glpi-version }}' | sed -E 's|/|-|')"
          if [[ "${{ inputs.image-suffix }}" != '' ]]; then
            IMAGE_VERSION="$IMAGE_VERSION-${{ inputs.image-suffix }}"
          fi
          echo "image_version=$IMAGE_VERSION" >> $GITHUB_OUTPUT

          # Detect prerelease (contains -rc, -beta, -alpha, etc.)
          PRERELEASE_FLAG="$( echo "${{ inputs.glpi-version }}" | grep -Po '(\-\w+)?$' )"
          if [[ -n "$PRERELEASE_FLAG" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

          # Check if this is the latest release (only for non-prereleases)
          IS_LATEST="false"
          if [[ -z "$PRERELEASE_FLAG" && "${{ inputs.image-tag }}" == '' ]]; then
            LATEST_TAG="$(curl -s https://api.github.com/repos/glpi-project/glpi/releases/latest | jq -r .tag_name)"
            if [[ "${{ inputs.glpi-version }}" = "$LATEST_TAG" ]]; then
              IS_LATEST="true"
            fi
          fi
          echo "is_latest=$IS_LATEST" >> $GITHUB_OUTPUT

  build:
    name: "Build [${{ matrix.platform.suffix }}]"
    runs-on: "${{ matrix.platform.runner }}"
    needs: [prepare]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: "linux/amd64", runner: "ubuntu-24.04", suffix: "amd64" }
          - { arch: "linux/arm64", runner: "ubuntu-24.04-arm", suffix: "arm64" }
    steps:
      - name: "Checkout"
        uses: "actions/checkout@v6"

      - name: "Prepare environment"
        run: |
          platform="${{ matrix.platform.arch }}"
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: "Docker meta"
        id: "meta"
        uses: "docker/metadata-action@v5"
        with:
          images: |
            ${{ env.DOCKERHUB_IMAGE }}
            ${{ env.GHCR_IMAGE }}

      - name: "Set up QEMU"
        uses: "docker/setup-qemu-action@v3"

      - name: "Set up Docker Buildx"
        uses: "docker/setup-buildx-action@v3"

      - name: "Login to DockerHub"
        uses: "docker/login-action@v3"
        with:
          username: "${{ secrets.DOCKER_HUB_USERNAME }}"
          password: "${{ secrets.DOCKER_HUB_TOKEN }}"

      - name: "Login to Github container registry"
        uses: "docker/login-action@v3"
        with:
          registry: "ghcr.io"
          username: "${{ secrets.GHCR_USERNAME }}"
          password: "${{ secrets.GHCR_ACCESS_TOKEN }}"

      - name: "Build and push by digest"
        id: "build"
        uses: "docker/build-push-action@v6"
        with:
          build-args: |
            GLPI_VERSION=${{ inputs.glpi-version }}
            GLPI_PATCH_URL=${{ inputs.patch-url }}
            BUILDER_IMAGE=php:${{ inputs.php-version }}-cli-alpine
            APP_IMAGE=php:${{ inputs.php-version }}-apache
            GLPI_MARKETPLACE_DIR=${{ needs.prepare.outputs.marketplace-dir }}
          cache-from: |
            type=gha,scope=${{ github.ref_name }}-${{ matrix.platform.suffix }}
            type=gha,scope=main-${{ matrix.platform.suffix }}
          cache-to: "type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.platform.suffix }}"
          context: "glpi"
          labels: "${{ steps.meta.outputs.labels }}"
          platforms: "${{ matrix.platform.arch }}"
          pull: true
          sbom: ${{ inputs.push }}
          provenance: ${{ inputs.push && 'mode=max' || 'false' }}
          outputs: "type=image,\"name=${{ env.DOCKERHUB_IMAGE }},${{ env.GHCR_IMAGE }}\",push-by-digest=true,name-canonical=true,push=${{ inputs.push }}"

      - name: "Export digest"
        if: ${{ inputs.push }}
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"

      - name: "Upload digest"
        if: ${{ inputs.push }}
        uses: "actions/upload-artifact@v4"
        with:
          name: "digests-${{ needs.prepare.outputs.artifact-prefix }}-${{ env.PLATFORM_PAIR }}"
          path: "${{ runner.temp }}/digests/*"
          if-no-files-found: "error"
          retention-days: 1

  merge-manifests:
    name: "Merge manifests"
    runs-on: "ubuntu-latest"
    needs: [prepare, build]
    if: ${{ inputs.push }}
    steps:
      - name: "Download digests"
        uses: "actions/download-artifact@v4"
        with:
          path: "${{ runner.temp }}/digests"
          pattern: "digests-${{ needs.prepare.outputs.artifact-prefix }}-*"
          merge-multiple: true
      - name: "Verify digests"
        run: |
          mkdir -p "${{ runner.temp }}/digests"
          if [ -z "$(ls -A ${{ runner.temp }}/digests)" ]; then
            echo "::error::No digest files found! Build job may have failed or artifacts expired."
            exit 1
          fi
      - name: "Set up Docker Buildx"
        uses: "docker/setup-buildx-action@v3"
      - name: "Login to DockerHub"
        uses: "docker/login-action@v3"
        with:
          username: "${{ secrets.DOCKER_HUB_USERNAME }}"
          password: "${{ secrets.DOCKER_HUB_TOKEN }}"
      - name: "Login to Github container registry"
        uses: "docker/login-action@v3"
        with:
          registry: "ghcr.io"
          username: "${{ secrets.GHCR_USERNAME }}"
          password: "${{ secrets.GHCR_ACCESS_TOKEN }}"
      - name: "Docker meta"
        id: "meta"
        uses: "docker/metadata-action@v5"
        with:
          images: |
            ${{ env.DOCKERHUB_IMAGE }}
            ${{ env.GHCR_IMAGE }}
          # Disable automatic latest tag - we control it via is-latest
          flavor: |
            latest=false
          tags: |
            # If image-tag is explicitly provided, use it directly
            type=raw,value=${{ inputs.image-tag }},enable=${{ inputs.image-tag != '' }}
            # Base version tag (always, when no explicit image-tag)
            type=raw,value=${{ needs.prepare.outputs.image-version }},enable=${{ inputs.image-tag == '' }}
            # only for releases
            type=semver,pattern={{major}},value=${{ inputs.glpi-version }},enable=${{ inputs.image-tag == '' && needs.prepare.outputs.is-prerelease == 'false' }}
            type=semver,pattern={{major}}.{{minor}},value=${{ inputs.glpi-version }},enable=${{ inputs.image-tag == '' && needs.prepare.outputs.is-prerelease == 'false' }}

            # Latest
            type=raw,value=latest,enable=${{ needs.prepare.outputs.is-latest == 'true' }}
      - name: "Create and push manifest"
        working-directory: "${{ runner.temp }}/digests"
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          # Create manifest for DockerHub
          DOCKERHUB_TAGS=$(echo "$TAGS" | grep "^${{ env.DOCKERHUB_IMAGE }}" | xargs -I {} echo "-t {}" | tr '\n' ' ')
          if [[ -n "$DOCKERHUB_TAGS" ]]; then
            echo "Creating DockerHub manifest..."
            docker buildx imagetools create $DOCKERHUB_TAGS \
              $(printf '${{ env.DOCKERHUB_IMAGE }}@sha256:%s ' *)
          fi

          # Create manifest for GHCR
          GHCR_TAGS=$(echo "$TAGS" | grep "^${{ env.GHCR_IMAGE }}" | xargs -I {} echo "-t {}" | tr '\n' ' ')
          if [[ -n "$GHCR_TAGS" ]]; then
            echo "Creating GHCR manifest..."
            docker buildx imagetools create $GHCR_TAGS \
              $(printf '${{ env.GHCR_IMAGE }}@sha256:%s ' *)
          fi
      - name: "Inspect image"
        run: |
          # Get first tag for inspection
          docker buildx imagetools inspect ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
