name: "GLPI Docker Image Build (Template)"

# This is a reusable workflow template - never run directly
# Called by: glpi.yml, glpi-nightly.yml

env:
  DOCKERHUB_IMAGE: benoitvignal/glpi_docker-images
  GHCR_IMAGE: ghcr.io/froozeify/glpi_docker-images

on:
  workflow_call:
    inputs:
      push:
        description: "Whether to push images to registries"
        required: false
        type: boolean
        default: false
      patch-url:
        description: "URL to a .diff/.patch file to apply after source download, multiple patches can be separated by space"
        required: false
        type: string
        default: ""
      php-version:
        required: false
        type: string
        default: "8.5"
      glpi-version:
        description: "GLPI version or branch to build"
        required: true
        type: string
      image-tag:
        description: "Override image tag. If not set, computed from version."
        required: false
        type: string
        default: ""
      image-suffix:
        description: "Suffix to add to computed tag (ignored if image-tag is set)"
        required: false
        type: string
        default: ""
    secrets:
      DOCKER_HUB_USERNAME:
        required: true
      DOCKER_HUB_TOKEN:
        required: true
      GHCR_USERNAME:
        required: true
      GHCR_ACCESS_TOKEN:
        required: true

jobs:
  prepare:
    name: "Prepare"
    runs-on: "ubuntu-latest"
    outputs:
      marketplace-dir: ${{ steps.set-vars.outputs.marketplace_dir }}
      artifact-prefix: ${{ steps.set-vars.outputs.artifact_prefix }}
      is-latest: ${{ steps.set-vars.outputs.is_latest }}
      is-latest-major: ${{ steps.set-vars.outputs.is_latest_major }}
      sha-source-commit: ${{ steps.set-vars.outputs.sha_source_commit }}
      image-version: ${{ steps.set-vars.outputs.image_version }}
    steps:
      - name: "Set variables"
        id: "set-vars"
        run: |
          GLPI_VERSION="${{ inputs.glpi-version }}"
          IMAGE_TAG="${{ inputs.image-tag }}"
          IMAGE_SUFFIX="${{ inputs.image-suffix }}"

          # Determine if glpi-version is a semver tag (e.g., 10.0.18, 11.0.5-rc1)
          # vs a branch, commit hash, or URL
          IS_SEMVER=false
          if echo "$GLPI_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+'; then
            IS_SEMVER=true
          fi

          # Fetch the commit SHA for this version/branch (for cache-busting)
          # Same commit = cache hit, new commit = fresh build
          if echo "$GLPI_VERSION" | grep -qE '^https://'; then
            # For URLs, use empty (will always rebuild)
            SOURCE_COMMIT=""
          elif [[ "$GLPI_VERSION" = "latest" ]]; then
            # Resolve "latest" to actual tag first, then get commit SHA
            RESOLVED_TAG=$(curl -s "https://api.github.com/repos/glpi-project/glpi/releases/latest" | jq -r '.tag_name')
            SOURCE_COMMIT=$(curl -s "https://api.github.com/repos/glpi-project/glpi/commits/$RESOLVED_TAG" | jq -r '.sha // empty')
          else
            SOURCE_COMMIT=$(curl -s "https://api.github.com/repos/glpi-project/glpi/commits/$GLPI_VERSION" | jq -r '.sha // empty')
          fi
          echo "sha_source_commit=$SOURCE_COMMIT" >> $GITHUB_OUTPUT

          # Compute marketplace dir (only v10 uses old path)
          MARKETPLACE_DIR="/var/glpi/marketplace"
          if [[ "$IS_SEMVER" = "true" ]]; then
            IMAGE_VERSION_MAJOR=$(echo "$GLPI_VERSION" | cut -d. -f1)
            if [[ "$IMAGE_VERSION_MAJOR" = "10" ]]; then
              MARKETPLACE_DIR="/var/www/glpi/marketplace"
            fi
          fi
          echo "marketplace_dir=$MARKETPLACE_DIR" >> $GITHUB_OUTPUT

          # Compute artifact prefix (unique per workflow call)
          if [[ "$IMAGE_TAG" != '' ]]; then
            ARTIFACT_PREFIX="$IMAGE_TAG"
          else
            # Replace slashes and colons with dashes for branches like 11.0/bugfixes
            ARTIFACT_PREFIX="$(echo "$GLPI_VERSION" | sed -E 's|[/:]|-|g' | sed -E 's|https?--||')"
          fi
          echo "artifact_prefix=$ARTIFACT_PREFIX" >> $GITHUB_OUTPUT

          # Compute image version for metadata-action
          if [[ "$IMAGE_TAG" != '' ]]; then
            IMAGE_VERSION="$IMAGE_TAG"
          else
            IMAGE_VERSION="$(echo "$GLPI_VERSION" | sed -E 's|[/:]|-|g' | sed -E 's|https?--||')"
            if [[ "$IMAGE_SUFFIX" != '' ]]; then
              IMAGE_VERSION="$IMAGE_VERSION-$IMAGE_SUFFIX"
            fi
          fi
          echo "image_version=$IMAGE_VERSION" >> $GITHUB_OUTPUT

          # Skip all version checks if:
          # - image-tag is provided (explicit override)
          # - glpi-version is not a semver (branch, commit, URL)
          if [[ "$IMAGE_TAG" != '' ]] || [[ "$IS_SEMVER" != "true" ]]; then
            echo "is_latest=false" >> $GITHUB_OUTPUT
            echo "is_latest_major=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Detect prerelease (contains -rc, -beta, -alpha, etc.)
          PRERELEASE_FLAG="$( echo "$GLPI_VERSION" | grep -Po '(\-\w+)?$' )"
          if [[ -n "$PRERELEASE_FLAG" ]]; then
            echo "is_latest=false" >> $GITHUB_OUTPUT
            echo "is_latest_major=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if this is the latest release overall
          LATEST_TAG=$(curl -s "https://api.github.com/repos/glpi-project/glpi/releases/latest" | jq -r '.tag_name')
          if [[ "$GLPI_VERSION" = "$LATEST_TAG" ]]; then
            echo "is_latest=true" >> $GITHUB_OUTPUT
          else
            echo "is_latest=false" >> $GITHUB_OUTPUT
          fi

          # Fetch all releases from GitHub API (non-prerelease only) for major series check
          RELEASES=$(curl -s "https://api.github.com/repos/glpi-project/glpi/releases?per_page=100" | jq -r '[.[] | select(.prerelease == false) | .tag_name]')

          # Check if this is the latest in its major series (e.g., latest 11.x.x)
          IMAGE_VERSION_MAJOR=$(echo "$GLPI_VERSION" | cut -d. -f1)
          LATEST_IN_MAJOR=$(echo "$RELEASES" | jq -r --arg major "$IMAGE_VERSION_MAJOR" '[.[] | select(startswith($major + "."))] | .[0] // empty')
          if [[ "$GLPI_VERSION" = "$LATEST_IN_MAJOR" ]]; then
            echo "is_latest_major=true" >> $GITHUB_OUTPUT
          else
            echo "is_latest_major=false" >> $GITHUB_OUTPUT
          fi

  build:
    name: "Build [${{ matrix.platform.suffix }}]"
    runs-on: "${{ matrix.platform.runner }}"
    needs: [prepare]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: "linux/amd64", runner: "ubuntu-24.04", suffix: "amd64" }
          - { arch: "linux/arm64", runner: "ubuntu-24.04-arm", suffix: "arm64" }
    steps:
      - name: "Checkout"
        uses: "actions/checkout@v6"

      - name: "Prepare environment"
        run: |
          platform="${{ matrix.platform.arch }}"
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: "Docker metadata"
        id: "meta"
        uses: "docker/metadata-action@v5"
        with:
          images: |
            ${{ env.DOCKERHUB_IMAGE }}
            ${{ env.GHCR_IMAGE }}

      - name: "Set up QEMU"
        uses: "docker/setup-qemu-action@v3"

      - name: "Set up Docker Buildx"
        uses: "docker/setup-buildx-action@v3"

      - name: "Login to DockerHub"
        uses: "docker/login-action@v3"
        with:
          username: "${{ secrets.DOCKER_HUB_USERNAME }}"
          password: "${{ secrets.DOCKER_HUB_TOKEN }}"

      - name: "Login to Github container registry"
        uses: "docker/login-action@v3"
        with:
          registry: "ghcr.io"
          username: "${{ secrets.GHCR_USERNAME }}"
          password: "${{ secrets.GHCR_ACCESS_TOKEN }}"

      - name: "Build and push by digest"
        id: "build"
        uses: "docker/build-push-action@v6"
        with:
          build-args: |
            GLPI_VERSION=${{ inputs.glpi-version }}
            GLPI_PATCH_URL=${{ inputs.patch-url }}
            GLPI_SHA_SOURCE_COMMIT=${{ needs.prepare.outputs.sha-source-commit }}
            BUILDER_IMAGE=php:${{ inputs.php-version }}-cli-alpine
            APP_IMAGE=php:${{ inputs.php-version }}-apache
            GLPI_MARKETPLACE_DIR=${{ needs.prepare.outputs.marketplace-dir }}
          cache-from: |
            type=gha,scope=${{ github.ref_name }}-${{ matrix.platform.suffix }}
            type=gha,scope=main-${{ matrix.platform.suffix }}
          cache-to: "type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.platform.suffix }}"
          context: "glpi"
          labels: "${{ steps.meta.outputs.labels }}"
          platforms: "${{ matrix.platform.arch }}"
          pull: true
          sbom: ${{ inputs.push }}
          provenance: ${{ inputs.push && 'mode=max' || 'false' }}
          outputs: "type=image,\"name=${{ env.DOCKERHUB_IMAGE }},${{ env.GHCR_IMAGE }}\",push-by-digest=true,name-canonical=true,push=${{ inputs.push }}"

      - name: "Export digest"
        if: ${{ inputs.push }}
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"

      - name: "Upload digest"
        if: ${{ inputs.push }}
        uses: "actions/upload-artifact@v4"
        with:
          name: "digests-${{ needs.prepare.outputs.artifact-prefix }}-${{ env.PLATFORM_PAIR }}"
          path: "${{ runner.temp }}/digests/*"
          if-no-files-found: "error"
          retention-days: 1

  merge-manifests:
    name: "Merge manifests"
    runs-on: "ubuntu-latest"
    needs: [prepare, build]
    if: ${{ inputs.push }}
    steps:
      - name: "Download digests"
        uses: "actions/download-artifact@v4"
        with:
          path: "${{ runner.temp }}/digests"
          pattern: "digests-${{ needs.prepare.outputs.artifact-prefix }}-*"
          merge-multiple: true
      - name: "Verify digests"
        run: |
          mkdir -p "${{ runner.temp }}/digests"
          if [ -z "$(ls -A ${{ runner.temp }}/digests)" ]; then
            echo "::error::No digest files found! Build job may have failed or artifacts expired."
            exit 1
          fi
      - name: "Set up Docker Buildx"
        uses: "docker/setup-buildx-action@v3"
      - name: "Login to DockerHub"
        uses: "docker/login-action@v3"
        with:
          username: "${{ secrets.DOCKER_HUB_USERNAME }}"
          password: "${{ secrets.DOCKER_HUB_TOKEN }}"
      - name: "Login to Github container registry"
        uses: "docker/login-action@v3"
        with:
          registry: "ghcr.io"
          username: "${{ secrets.GHCR_USERNAME }}"
          password: "${{ secrets.GHCR_ACCESS_TOKEN }}"
      - name: "Docker metadata"
        id: "meta"
        uses: "docker/metadata-action@v5"
        with:
          images: |
            ${{ env.DOCKERHUB_IMAGE }}
            ${{ env.GHCR_IMAGE }}
          # Disable automatic latest tag - we control it via is-latest
          flavor: |
            latest=false
          tags: |
            # If image-tag is explicitly provided, use it directly
            type=raw,value=${{ inputs.image-tag }},enable=${{ inputs.image-tag != '' }}
            # Base version tag (always, when no explicit image-tag)
            type=raw,value=${{ needs.prepare.outputs.image-version }},enable=${{ inputs.image-tag == '' }}

            # Only for releases
            type=semver,pattern={{major}},value=${{ inputs.glpi-version }},enable=${{ needs.prepare.outputs.is-latest-major == 'true' }}
            type=semver,pattern={{major}}.{{minor}},value=${{ inputs.glpi-version }},enable=${{ needs.prepare.outputs.is-latest-major == 'true' }}

            # Latest
            type=raw,value=latest,enable=${{ needs.prepare.outputs.is-latest == 'true' }}
      - name: "Create and push manifest"
        working-directory: "${{ runner.temp }}/digests"
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          # Create manifest for DockerHub
          DOCKERHUB_TAGS=$(echo "$TAGS" | grep "^${{ env.DOCKERHUB_IMAGE }}" | xargs -I {} echo "-t {}" | tr '\n' ' ')
          if [[ -n "$DOCKERHUB_TAGS" ]]; then
            echo "Creating DockerHub manifest..."
            docker buildx imagetools create $DOCKERHUB_TAGS \
              $(printf '${{ env.DOCKERHUB_IMAGE }}@sha256:%s ' *)
          fi

          # Create manifest for GHCR
          GHCR_TAGS=$(echo "$TAGS" | grep "^${{ env.GHCR_IMAGE }}" | xargs -I {} echo "-t {}" | tr '\n' ' ')
          if [[ -n "$GHCR_TAGS" ]]; then
            echo "Creating GHCR manifest..."
            docker buildx imagetools create $GHCR_TAGS \
              $(printf '${{ env.GHCR_IMAGE }}@sha256:%s ' *)
          fi
      - name: "Inspect image"
        run: |
          # Get first tag for inspection
          docker buildx imagetools inspect ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
